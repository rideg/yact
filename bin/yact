#!/usr/bin/env bash

################################################################################
# Shows help.
# -- Globals: none
# -- Input: none
# -- Output: Help message.
################################################################################
_show_help() {
  echo "Yact - Yet Another Commandline Todo" 
  echo "Usage: yact [-lhv] [command] ..."
}

################################################################################
# Prints version string.
# -- Globals: none
# -- Input: none
# -- Output: Version string.
################################################################################
_show_version() {
  cat .version
}

################################################################################
# Main entry point for YACT.
# -- Globals:
#  TRACE - enables tracing if set.
#  YACT_DIR - Working directory for YACT.
#  TODO_FILE - The file name of the current list.
#  RUN - Directory for runtime temproray files.
# -- Input: Command.
# -- Output: The result of the command.
################################################################################
# shellcheck source=/dev/null
main() {
  [[ "$TRACE" ]] && set -x

  pushd ${0%/*} &> /dev/null
  cd ..

  [[ -d "${YACT_DIR}" ]] || YACT_DIR=~/.yact
  RUN=$YACT_DIR/.run

  [[ -d $RUN ]] || mkdir -p $RUN
  . ./config

  [[ -f $YACT_DIR/config ]] && . "$YACT_DIR"/config

  . lib/util.sh
  . lib/formatting.sh
  [[ -f $YACT_DIR/.last ]] && . "$YACT_DIR"/.last
  export FILE=$YACT_DIR/$TODO_FILE

  case "$1" in
    -v) _show_version;;
    -h) _show_help;;
    -l) shift; _parse_list_opts "$@";;
    *) _parse_task_opts "$@";;
  esac
  exit_ 0
}

################################################################################
# Reads the current todo file from the disk.
# -- Globals:
#  FILE - Current todo list's file.
#  HEADER - Current todo's header.
#  TASKS - Current todo's tasks array.
#  __ORIGINAL_TASKS - Current todo's tasks array (original).
# -- Inputs: none
# -- Output: none
################################################################################
read_file() {
  readarray -t __ < "$FILE"
  export TASKS=("${__[@]:2}")
  export __ORIGINAL_TASKS=("${__[@]:2}")
  export HEADER="${__[0]}"
}

################################################################################
# Flushes the current todo file to the disk if changed.
# -- Globals:
#  FILE - Current todo list's file.
#  HEADER - Current todo's header.
#  TASKS - Current todo's tasks array.
#  __ORIGINAL_TASKS - Current todo's tasks array (original).
# -- Inputs: none
# -- Output: none
################################################################################
flush_file() {
  local changed=false
  [[ ${#TASKS[@]} -ne ${#__ORIGINAL_TASKS[@]} ]] && changed=true
  if ! $changed; then
    for (( i=0; i< ${#TASKS[@]}; i++ )); do
      if [[ "${TASKS[$i]}" != "${__ORIGINAL_TASKS[$i]}" ]]; then
        changed=true
        break
      fi
    done  
  fi
  if $changed; then 
    printf '%s\n\n' "$HEADER" > "$FILE"
    printf '%s\n' "${TASKS[@]}" >> "$FILE"
  fi
}

################################################################################
# Checks if the the actual list exists and if so then reads it to a global
# array.
# -- Globals:
#  FILE - Current todo list's file.
#  FILE_CONTENT - lines of the file as an array.
# -- Input: Arguments for list operations.
# -- Output: None.
################################################################################
_require_actual() {
  [[ -f "$FILE" ]] || \
    fatal 'No todo list has been selected, please select/create one.'
  read_file
}

################################################################################
# Parses the options for lists.
# -- Globals: None.
# -- Input: Arguments for list operations.
# -- Output: None.
################################################################################
_parse_list_opts() {
  local cmd=$1
  shift
  if [[ "$cmd" != 'new' ]]; then
    _require_actual
  fi
  . lib/lists.sh
  if [[ -n "$cmd" ]]; then
    case $cmd in
      switch) switch_list "$1";;
      new) new_list "$@";;
      delete) delete_list "$1";;
      modify) modify_list "$@";;
      show) show_list; return 0;;
      *) fatal "Cannot recognize command: $cmd"
    esac
    . lib/tasks.sh
    show_tasks
  else
    show_lists
  fi
}

################################################################################
# Parses the options for tasks.
# -- Globals: None.
# -- Input: Arguments for task operations.
# -- Output: None.
################################################################################
_parse_task_opts() {
  _require_actual
  local cmd=$1
  shift
  . lib/tasks.sh
  . lib/config.sh
  if [[ -n "$cmd" ]]; then
    case $cmd in
      add) add_task "$@";;
      delete) delete_task "$@";;
      modify) modify_task "$@";;
      move) move_task "$1" "$2";;
      'done') set_done "$1" 1;;
      undone) set_done "$1" 0;;
      config) set_config "$1";;
      show) ;;
      *) fatal "Cannot recognize command: $cmd";;
    esac
  fi
  show_tasks
  flush_file
}

main "$@"

