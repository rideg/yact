#!/usr/bin/env bash

################################################################################
# Shows help.
# -- Globals: none
# -- Input: none
# -- Output: Help message.
################################################################################
_show_help() {
  echo "Yact - Yet Another Commandline Todo"
  echo "Usage: yact [-lhv] [command] ..."
}

################################################################################
# Prints version string.
# -- Globals: none
# -- Input: none
# -- Output: Version string.
################################################################################
_show_version() {
  cat .version
}

################################################################################
# Initialises the pipe which can be used to avoid subshell creation when we
# need to store the output of some arbitrary command.
# -- Globals:
#  RUN - Directory for runtime temporary files.
# -- Input: none
# -- Output: Version string.
################################################################################
_init_pipe() {
  [[ -p "${RUN}/.pipe" ]] || mkfifo "${RUN}/.pipe"
  exec 9<> "${RUN}/.pipe"
}

################################################################################
# Main entry point for YACT.
# -- Globals:
#  TRACE - enables tracing if set.
#  YACT_DIR - Working directory for YACT.
#  TODO_FILE - The file name of the current list.
#  RUN - Directory for runtime temporary files.
#  YACT_PATCH_DIR - Directory for storage patches.
#  STORAGE_DIR - storage
# -- Input: Command.
# -- Output: The result of the command.
################################################################################
# shellcheck source=/dev/null
main() {
  [[ "$TRACE" ]] && set -x

	# shellcheck disable=SC2164
  pushd "${0%/*}" &> /dev/null
  cd ..

  [[ -d "${YACT_DIR}" ]] || YACT_DIR=~/.yact
  RUN=$YACT_DIR/.run

  [[ -d $RUN ]] || mkdir -p "$RUN"
  . ./config

  [[ -f $YACT_DIR/config ]] && . "$YACT_DIR"/config

  export STORAGE_DIR=$YACT_DIR/storage
  [[ -d $STORAGE_DIR ]] || mkdir -p "$STORAGE_DIR"

  export YACT_PATCH_DIR=${YACT_PATCH_DIR:-patches}

  . lib/util.sh
  . lib/formatting.sh
  [[ -f $RUN/.last ]] && . "$RUN"/.last
  export FILE=$TODO_FILE

  _init_pipe
  _init_formatting

  case "$1" in
    -v) _show_version;;
    -h) _show_help;;
    -l) shift; _parse_list_opts "$@";;
    -a) shift; _parse_admin_opts "$@";;
    *) _parse_task_opts "$@";;
  esac
  exit_ 0
}


################################################################################
# Checks if the actual list exists and if so then reads it to a global
# array.
# -- Globals:
#  FILE - Current todo list's file.
#  FILE_CONTENT - lines of the file as an array.
# -- Input: Arguments for list operations.
# -- Output: None.
################################################################################
_require_actual() {
  [[ -f "$FILE" ]] || \
    fatal 'No todo list has been selected, please select/create one.'
  read_task_file
  store_current
}

################################################################################
# Parses the options for lists.
# -- Globals: None.
# -- Input: Arguments for list operations.
# -- Output: None.
################################################################################
_parse_list_opts() {
  local cmd=$1
  shift
	read_lists
  if [[ "$cmd" != 'new' ]]; then
    _require_actual
  fi
  . lib/lists.sh
  if [[ -n "$cmd" ]]; then
    case $cmd in
      switch) yact::list::switch "$1";;
      new) yact::list::new "$@";;
      delete) yact::list::delete "$1";;
      modify) yact::list::modify "$@";;
      show) yact::list::show; return 0;;
      *) fatal "Cannot recognize command: $cmd"
    esac
    . lib/tasks.sh
    show_tasks
  else
    yact::list::show
  fi
}

################################################################################
# Parses the options for tasks.
# -- Globals: None.
# -- Input: Arguments for task operations.
# -- Output: None.
################################################################################
_parse_task_opts() {
  _require_actual
  local cmd=$1
  shift
  . lib/tasks.sh
  if [[ -n "$cmd" ]]; then
    case $cmd in
      add) add_task "$@";;
      delete) delete_task "$@";;
      modify) modify_task "$@";;
      move) move_task "$1" "$2";;
      'done') set_done "$1" 1;;
      undone) set_done "$1" 0;;
      swap) swap_tasks "$1" "$2";;
      reverse) reverse_tasks;;
      show) ;;
      *) fatal "Cannot recognize command: $cmd";;
    esac
  fi
  show_tasks
  flush_task_file
}

################################################################################
# Parses the options for admin related tasks.
# -- Globals: None.
# -- Input: Arguments for task operations.
# -- Output: None.
################################################################################
_parse_admin_opts() {
  local cmd=$1
  shift
  [[ -z $cmd ]] && fatal "Please provide an admin command"
  case $cmd in
    config)
      . lib/config.sh
      local subcmd=$1
      shift
      case $subcmd in
        set) yact::config::set_config "$1" "$2";;
        'unset') yact::config::unset_config "$1";;
        get) yact::config::get_config "$1";;
        list|"") yact::config::print_config  "$1";;
        '-c') yact::config::print_config -c;;
        *) fatal "Unknown command: $subcmd";;
      esac
      ;;
    migrate)
      . lib/migrate.sh
      migrate_storage
      ;;
    *) fatal "Unknown command: $cmd";;
  esac
}

main "$@"

